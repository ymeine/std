require! {
# -------------------------------------------------------------------------- STD
	fs
# -------------------------------------------------------------------------- 3rd
	moment
# ---------------------------------------------------------------------- Own STD
	'string'
	'./conf'
# ----------------------------------------------------------- Dynamically loaded
	# LiveScript
	# xml2js
	# csv
}



################################################################################
# TODO Be able to pass an object with a single key to 'write' methods. This way, the key is the file name and the property the data. This allows to use the LiveScript shorthand while calling, like this: `io.write {data}` (writing to the filename)
# It is more likely to be done for JSON writing, which has a default extension
# TODO Change the way conf is used
################################################################################
class IO
	(spec = {}) ~> @conf = conf with spec

	stampDate = -> moment!format 'DD-MM-YYYY_hh-mm-ss.SSSa'

	############################################################################
	# Basic IO
	############################################################################

	read: (path, encoding) ->
		encoding ?= @conf.encoding

		fs.readFileSync path, encoding

	write: fs.writeFileSync

	############################################################################
	# File stats
	############################################################################

	@fileDatesMapping = {
		'modification': 'mtime'
		'creation': 'ctime'
		'access': 'atime'
	}

	getDate: (type, path) --> (fs.statSync path)[@@fileDatesMapping[type] ? @@fileDatesMapping[@conf.defaultFileDate]]

	modificationDate: ::getDate 'modification'
	creationDate: ::getDate 'creation'
	accessDate: ::getDate 'access'

	############################################################################
	# LiveScript Serialization
	############################################################################

	lsc:~ -> require 'LiveScript/lib/livescript'

	/** The evaluated code must return the object to be imported */
	loadLscJSON: (code) -> @lsc.run code


	############################################################################
	# JSON Serialization
	############################################################################

	serializeJSON: (data, indent) ->
		indent ?= @conf.indent

		JSON.stringify data, null indent

	readJSON: (path, extension) ->
		if @conf.useReadJSONDefaultExtension => extension ?= ".json"
		extension ?= ''
		JSON.parse @read "#path#extension"

	importJSON: ::readJSON

	writeJSON: (path, data, extension = 'json') ~>
		if extension? => path = "#path.#extension"
		@write path, @serializeJSON data

	persistJSON: ::writeJSON



	serialize: ::serializeJSON
	import: ::importJSON
	persist: ::persistJSON


	############################################################################
	# XML Serialization
	#
	# XXX Maybe put some of it in the core 'data' library, if I'm able to work only with data (string, object, ...) and no file anymore
	#
	# FIXME The adapter is not good: I think it should recursively convert any 'xml lists'
	############################################################################

	xml2js:~ -> require 'xml2js'

	xml2json: (options, data, cb) -->
		{Parser} = new @xml2js
		parser = Parser options
		(err, result) <- parser.parseString data
		if not err? => cb(result.xml ? result) # [..$ for result.xml.entries.0.entry]



	############################################################################
	# CSV Serialization
	############################################################################

	csv:~ ->require 'csv'

	/**
	 * A record is equivalent to an object, a line inside the csv file.
	 * It is represented as an array.
	 * The provided headers configuration is an array mapping record indexes to key names for the resulting object: provide the names of the keys in the order they should 'appear' in the csv file.
	 */
	csv2json: ({input, options, headers}, cb) ->
		obj = []
		@csv!
			..from
				..options options
				..path input
			..on \record (record) -> obj.push {[key, record[index]] for key, index in headers}
			..on \end -> cb obj





/** Use the constructor link (@@) if you want to build other instances after a require */
module.exports = new IO!
