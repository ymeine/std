require! {
	node-path: path

	object: 'object/core'
	array: 'array/core'
}



exportValues = (exports, values) ->
	for value in values
		{
			value
			names
			api
		} = value

		# ---------------------------------------------------------------- value

		if not value? => continue
		# if _from? => value = _from.value

		# ---------------------------------------------------------------- names

		names = array.factory names

		# Processing -----------------------------------------------------------

		object.alias value, names, exports, yes

		# Return ---------------------------------------------------------------

		{
			value
			names
			api
		}



exportModules = (module, submodules, defaultUsePathAsName, defaultLazy) ->
	for submodule in submodules
		{
			path
			names
			usePathAsName
			lazy
			api
		} = submodule

		# ----------------------------------------------------------------- lazy

		lazy ?= defaultLazy
		lazy ?= yes

		# ----------------------------------------------------------------- path

		if not path? => continue

		# -------------------------------------------------------- usePathAsName

		usePathAsName ?= defaultUsePathAsName
		usePathAsName ?= yes

		# ---------------------------------------------------------------- names

		names = array.factory names
		if usePathAsName
			names = [node-path.basename path] ++ names

		# Not lazy mode --------------------------------------------------------

		{exports} = module

		if not lazy
			value = module.require path
			object.alias value, names, exports, yes

		# Lazy mode ------------------------------------------------------------

		else let module, path
			descriptor = {
				get: -> module.require path
				+enumerable
				+configurable
			}
			for name in names
				Object.defineProperty exports, name, descriptor

		# Return ---------------------------------------------------------------

		{
			path
			names
			usePathAsName
			lazy
			api
		}



_export = (spec) ->
	# Input processing ---------------------------------------------------------

	{
		module
		submodules
		values
		# from: _from

		# Options
		lazy
		usePathAsName
	} = spec

	# ------------------------------------------------------------------- module

	if not module? => throw Error 'No module given'

	# --------------------------------------------------------------- submodules

	submodules = switch typeof! submodules
	| 'Array' => submodules
	| 'Object' => [{path, names} for path, names of submodules]
	| _ => []

	submodules = for submodule in submodules
		switch typeof! submodule
		| 'Object' => submodule
		| 'String' => {path: submodule, names: [submodule]}
		| 'Array'
			if submodule.lenght is 0 => throw new Error 'Invalid submodule specification'
			{path: submodule.0, names: submodule}
		| _ => throw new Error 'Invalid submodule specification'

	# ------------------------------------------------------------------- values

	values = array.factory values

	# ------------------------------------------------------------------ options

	lazy ?= yes
	usePathAsName ?= yes

	# Processing ---------------------------------------------------------------

	submodules = exportModules module, submodules, usePathAsName, lazy
	values = exportValues module.exports, values

	if not module.exports.__module__? => Object.defineProperty module.exports, '__module__' {
		-configurable
		-enumerable
		-writable
		value: module
	}

	__spec__ = module.{}__spec__

	__spec__.submodules ?= []
	__spec__.submodules ++= submodules

	__spec__.values ?= []
	__spec__.values ++= values



export {
	export: _export

	exportValues

	exportModules
}
