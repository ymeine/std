require! {
# -------------------------------------------------------------------------- 3rd
	lodash
# ---------------------------------------------------------------------- Own-STD
	type: 'type/core'
}





################################################################################
# Splitting
################################################################################

split-pre-process = (chunkSize, array) ->
	# ------------------------------------------------------------------- Errors

	if not array? => throw {msg: 'No array given'}
	if not chunkSize? => throw {msg: 'No chunk size given'}
	if chunkSize <= 0 => throw {msg: 'Invalid given chunk size: must be strictly positive', chunkSize}

	# -------------------------------------------------------------- Adjustments

	if chunkSize > array.length => chunkSize = array.length

	# ------------------------------------------------------------------- Return

	{chunkSize, array}

/**
 * Divides the given array into arrays of given chunk size.
 *
 * The last one might not have a length of the given chunk size.
 *
 * @todo Be able to choose which part is going to take trhe remaining items (last has currently or first)
 */
split = (chunkSize, array) -->
	# ----------------------------------------------------------- Pre-processing

	{chunkSize, array} = split-pre-process chunkSize, array

	# --------------------------------------------------------------- Processing

	[array[offset til offset + chunkSize] for offset from 0 to array.length - 1 by chunkSize]





################################################################################
# Removal
################################################################################

/**
 * @inplace arg[0]
 * @chain arg[0]
 */
removeAt = (array, index) -->
	# ----------------------------------------------- Input arguments processing

	if not array? => throw {msg: 'No array given'}

	# --------------------------------------------------------------- Processing

	array.splice index, 1

	# ------------------------------------------------------------------- Return

	array



/**
 * @inplace arg[0]
 * @chain arg[0]
 */
remove = (array, element) -->
	# ----------------------------------------------- Input arguments processing

	if not array? => throw {msg: 'No array given'}

	# --------------------------------------------------------------- Processing

	index = array.indexOf element
	if index >= 0 => removeAt array, index

	# ------------------------------------------------------------------- Return

	array





################################################################################
# Factories
################################################################################

factory = (input) ->
	switch &length
	| 0 => []
	| 1
		switch
		| not input? => []
		| type.isArray input => input
		| _ => [input]
	| _ => Array.prototype.slice.call &





################################################################################
# Sorting
################################################################################

sortBy = (array, property, undefinedAtBegining) ->
	# ----------------------------------------------- Input arguments processing

	undefinedAtBegining ?= yes

	# -------------------------------------------------------- Split in 2 groups

	hasProp = (.[property]?)
	withProperty = lodash.select array, hasProp
	withoutProperty = lodash.reject array, hasProp

	# --------------------------------------------------------------------- Sort

	withProperty = lodash.sortBy withProperty, (.[property])

	# ---------------------------------------------------- Merge groups & return

	if undefinedAtBegining => withoutProperty ++ withProperty
	else withProperty ++ withoutProperty



################################################################################
# Transformation
################################################################################

/**
 * Equivalent of underscore/lodash map (in classical functional programming)
 */
transform = (cb, array, inplace) ->
	inplace ?= no

	if not inplace
		[cb item for item in array]
	else
		for item, index in array => array[index] = cb item
		array





export {
	split
	removeAt
	remove
	factory
	sortBy
	transform
}
