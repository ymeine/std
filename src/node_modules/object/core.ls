require! {
	type: 'type/core'
}





override = (original, newValues) ->
	newValues ?= {}

	for key, value of newValues
		if original[key]? => original[key] = value

	original



_default = (original, def) ->
	for key, value of def
		original[key] ?= value

	original



factory = (value, key) ->
	key ?= value

	if type.isObject value => value
	else {(key): value}


# FIXME The spec is not well defined
# The first use of transform is not simple: calling a callback, no added value
# the recursive method for now just handles the keys
# Add the real recursive, with links
transform = (obj, cb, recursive) ->
	recursive ?= no

	if not recursive => cb obj
	else {[key, cb[key](value)] for key, value of obj}


# See implementation in node.ls (Node.prototype.transform)
# See override in tester.ls
transform-rec = (obj, link, cb) ->
	# ! Depth-first implementation
	# ! Assuming the link exists
	# ! Assuming the link holds an array
	# ! Assuming this array is always present, and empty to stop the recursion
	transformedRec = [transform-rec child, link, cb for obj[link]]
	cb obj, transformedRec

/**
 * Creates or update an object with the given value, put under all the given property names.
 */
alias = (value, names, output, safe) ->
	# ----------------------------------------------- Input arguments processing

	output ?= {}
	safe ?= no

	# --------------------------------------------------------------- Processing

	if safe
		for name in names => output[name] ?= value
	else
		for name in names => output[name] = value


	# ------------------------------------------------------------------- Return

	output



export {
	override

	default: _default

	factory

	# transform

	alias
}
